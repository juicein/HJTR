<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>å…¬äº¤ / è½¨é“ æ•°æ®åŒå‘è½¬æ¢å™¨</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- SheetJSï¼ˆExcel è§£æä¸å¯¼å‡ºï¼‰ -->
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

<style>
/* ===== Material 3 Expressive ===== */
:root{
  --md-primary:#6750A4;
  --md-surface:#FFFBFE;
  --md-outline:#CAC4D0;
  --md-radius:16px;
}
body{
  margin:0;
  font-family:system-ui,-apple-system;
  background:var(--md-surface);
  color:#1C1B1F;
}
header{
  padding:20px;
  font-size:22px;
  font-weight:600;
}
.card{
  margin:16px;
  padding:16px;
  border-radius:var(--md-radius);
  background:#fff;
  box-shadow:0 1px 6px rgba(0,0,0,.1);
}
select,button,input,textarea{
  width:100%;
  margin-top:10px;
  padding:12px;
  border-radius:12px;
  border:1px solid var(--md-outline);
  font-size:15px;
}
button{
  background:var(--md-primary);
  color:#fff;
  border:none;
}
button.secondary{
  background:#E8DEF8;
  color:#21005D;
}
textarea{
  height:200px;
  font-family:monospace;
}
.row{
  display:flex;
  gap:10px;
  flex-wrap:wrap;
}
.row button{flex:1}
</style>
</head>

<body>
<header>ğŸšŒ å…¬äº¤ / è½¨é“ æ•°æ®åŒå‘è½¬æ¢å™¨</header>

<div class="card">
  <b>â‘  é€‰æ‹©åœ°åŒº</b>
  <select id="areaSelect"></select>
  <div class="row">
    <button onclick="exportCSV()">å¯¼å‡º CSV</button>
    <button onclick="exportExcel()">å¯¼å‡º Excel</button>
  </div>
</div>

<div class="card">
  <b>â‘¡ å¯¼å…¥ CSV / Excel</b>
  <input type="file" accept=".csv,.xlsx" onchange="importFile(this.files[0])">
</div>

<div class="card">
  <b>â‘¢ è½¬æ¢ç»“æœï¼ˆåŸå§‹æ ¼å¼ï¼‰</b>
  <textarea id="output"></textarea>
  <div class="row">
    <button class="secondary" onclick="copyText()">å¤åˆ¶</button>
    <button class="secondary" onclick="shareText()">ç³»ç»Ÿåˆ†äº«</button>
    <button class="secondary" onclick="downloadTXT()">å¯¼å‡º TXT</button>
  </div>
</div>

<script>
let rawLines = [];
let parsed = [];

/* ===== è¯»å– bus_data.txt ===== */
fetch('data/bus_data.txt')
.then(r => r.text())
.then(t => {
  rawLines = t.split(/\n+/).filter(l => l.trim());
  parseData();
});

/* ===== è§£æåŸå§‹æ ¼å¼ ===== */
function parseData(){
  parsed = [];
  const areas = new Set();

  rawLines.forEach(l => {
    const line = l.match(/ã€(.+?)ã€‘/)?.[1] || '';
    const stations = l.split('ã€‘')[1].split('-{')[0];
    const company = l.match(/\{(.+?)\}/)?.[1] || '';
    const price = l.match(/ã€Š(.+?)ã€‹/)?.[1] || '';
    const area = l.match(/ã€(.+?)ã€/)?.[1] || 'æœªçŸ¥';
    const start = l.match(/Â§(.+?)Â§/)?.[1] || '';
    const end = l.match(/@(.+?)@/)?.[1] || '';
    const color = l.match(/âˆ®(.+?)âˆ®/)?.[1] || '';

    let type = 'å…¬äº¤';
    const typeMatch = l.match(/Î¸(.+?)Î¸/);
    if(typeMatch) type = typeMatch[1];

    areas.add(area);

    parsed.push({
      line, stations, company, price,
      area, type, start, end, color
    });
  });

  areaSelect.innerHTML =
    [...areas].map(a => `<option>${a}</option>`).join('');
}

/* ===== å¯¼å‡º CSV ===== */
function exportCSV(){
  const area = areaSelect.value;
  let csv =
    'line,stations,company,price,area,type,start_time,end_time,color\n';

  parsed.filter(p => p.area === area).forEach(p => {
    csv += `"${p.line}","${p.stations}","${p.company}","${p.price}","${p.area}","${p.type}","${p.start}","${p.end}","${p.color}"\n`;
  });

  download(csv, `bus_${area}.csv`, 'text/csv');
}

/* ===== å¯¼å‡º Excel ===== */
function exportExcel(){
  const area = areaSelect.value;

  const rows = [
    ['line','stations','company','price','area','type','start_time','end_time','color']
  ];

  parsed.filter(p => p.area === area).forEach(p => {
    rows.push([
      p.line, p.stations, p.company, p.price,
      p.area, p.type, p.start, p.end, p.color
    ]);
  });

  const ws = XLSX.utils.aoa_to_sheet(rows);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'data');

  XLSX.writeFile(wb, `bus_${area}.xlsx`);
}

/* ===== å¯¼å…¥åˆ†æµ ===== */
function importFile(file){
  if(file.name.endsWith('.csv')){
    importCSV(file);
  }else if(file.name.endsWith('.xlsx')){
    importExcel(file);
  }else{
    alert('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼');
  }
}

/* ===== CSV â†’ åŸå§‹æ ¼å¼ ===== */
function importCSV(file){
  const r = new FileReader();
  r.onload = () => {
    convertRows(
      r.result.split('\n').slice(1)
      .map(row => row.match(/(".*?"|[^",]+)(?=\s*,|\s*$)/g)
      ?.map(s => s.replace(/^"|"$/g,'')))
    );
  };
  r.readAsText(file, 'utf-8');
}

/* ===== Excel â†’ åŸå§‹æ ¼å¼ ===== */
function importExcel(file){
  const r = new FileReader();
  r.onload = e => {
    const wb = XLSX.read(
      new Uint8Array(e.target.result),
      { type:'array' }
    );
    const ws = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(ws, { header:1 }).slice(1);
    convertRows(rows);
  };
  r.readAsArrayBuffer(file);
}

/* ===== è¡Œæ•°æ® â†’ åŸå§‹æ ¼å¼ ===== */
function convertRows(rows){
  let out = '';
  rows.forEach(c => {
    if(!c || !c.length) return;

    let txt = `ã€${c[0]}ã€‘${c[1]}-{${c[2]}}ã€Š${c[3]||''}ã€‹ã€${c[4]}ã€`;

    if(c[5] && c[5] !== 'å…¬äº¤'){
      txt += `Î¸${c[5]}Î¸`;
    }

    txt += `Â§${c[6]||''}Â§@${c[7]||''}@`;

    if(c[8]) txt += `âˆ®${c[8]}âˆ®`;

    out += txt + '\n';
  });
  output.value = out;
}

/* ===== å·¥å…· ===== */
function copyText(){
  navigator.clipboard.writeText(output.value);
}
function shareText(){
  navigator.share?.({ text: output.value });
}
function downloadTXT(){
  download(output.value,'bus_converted.txt','text/plain');
}
function download(data,name,type){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([data],{type}));
  a.download=name;
  a.click();
}
</script>
</body>
</html>
