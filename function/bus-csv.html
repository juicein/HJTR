<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>å…¬äº¤ / è½¨é“ æ•°æ®åŒå‘è½¬æ¢å™¨</title>
<meta name="viewport" content="width=device-width, initial-scale=1">

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.19.3/dist/xlsx.full.min.js"></script>

<style>
:root{
  --md-primary:#6750A4;
  --md-outline:#CAC4D0;
  --md-radius:16px;
}
body{
  margin:0;
  font-family:system-ui;
  background:#FFFBFE;
}
header{padding:20px;font-size:22px;font-weight:600;}
.card{
  margin:16px;
  padding:16px;
  border-radius:var(--md-radius);
  background:#fff;
  box-shadow:0 1px 6px rgba(0,0,0,.1);
}
select,button,input,textarea{
  width:100%;
  margin-top:10px;
  padding:12px;
  border-radius:12px;
  border:1px solid var(--md-outline);
}
button{background:var(--md-primary);color:#fff;border:none;}
textarea{height:200px;font-family:monospace;}
.error{
  white-space:pre-wrap;
  color:#B3261E;
  margin-top:10px;
  font-size:14px;
}
</style>
</head>

<body>
<header>ğŸšŒ å…¬äº¤ / è½¨é“ æ•°æ®åŒå‘è½¬æ¢å™¨</header>

<div class="card">
  <b>é€‰æ‹©åœ°åŒºå¹¶å¯¼å‡º</b>
  <select id="areaSelect"></select>
  <button onclick="exportCSV()">å¯¼å‡º CSV</button>
  <button onclick="exportExcel()">å¯¼å‡º Excel</button>
</div>

<div class="card">
  <b>å¯¼å…¥ CSV / Excel</b>
  <input type="file" accept=".csv,.xlsx" onchange="importFile(this.files[0])">
  <div id="errorBox" class="error"></div>
</div>

<div class="card">
  <b>è½¬æ¢ç»“æœï¼ˆåŸå§‹æ ¼å¼ï¼‰</b>
  <textarea id="output"></textarea>
</div>

<script>
let parsed=[], rawLines=[];

fetch('../data/bus_data.txt')
.then(r=>r.text())
.then(t=>{
  rawLines=t.split(/\n+/).filter(Boolean);
  parseRaw();
});

function parseRaw(){
  const areas=new Set();
  parsed=[];
  rawLines.forEach(l=>{
    const type=l.match(/Î¸(.+?)Î¸/)?.[1]||'å…¬äº¤';
    const obj={
      line:l.match(/ã€(.+?)ã€‘/)?.[1]||'',
      stations:l.split('ã€‘')[1]?.split('-{')[0]||'',
      company:l.match(/\{(.+?)\}/)?.[1]||'',
      price:l.match(/ã€Š(.+?)ã€‹/)?.[1]||'',
      area:l.match(/ã€(.+?)ã€/)?.[1]||'æœªçŸ¥',
      type,
      start:l.match(/Â§(.+?)Â§/)?.[1]||'',
      end:l.match(/@(.+?)@/)?.[1]||'',
      color:l.match(/âˆ®(.+?)âˆ®/)?.[1]||''
    };
    areas.add(obj.area);
    parsed.push(obj);
  });
  areaSelect.innerHTML=[...areas].map(a=>`<option>${a}</option>`).join('');
}

/* ===== CSV å¯¼å‡º ===== */
function exportCSV(){
  const area=areaSelect.value;
  let csv='line,stations,company,price,area,type,start_time,end_time,color\n';
  parsed.filter(p=>p.area===area).forEach(p=>{
    csv+=`${safe(p.line)},${safe(p.stations)},${safe(p.company)},${safe(p.price)},${safe(p.area)},${safe(p.type)},${safe(p.start)},${safe(p.end)},${safe(p.color)}\n`;
  });
  download(csv,'bus_'+area+'.csv','text/csv');
}

/* ===== Excel å¯¼å‡º ===== */
function exportExcel(){
  const area=areaSelect.value;
  const rows=[['line','stations','company','price','area','type','start_time','end_time','color']];
  parsed.filter(p=>p.area===area).forEach(p=>{
    rows.push([p.line,p.stations,p.company,p.price,p.area,p.type,p.start,p.end,p.color]);
  });
  const wb=XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb,XLSX.utils.aoa_to_sheet(rows),'data');
  XLSX.writeFile(wb,'bus_'+area+'.xlsx');
}

/* ===== å¯¼å…¥ ===== */
function importFile(file){
  errorBox.textContent='';
  output.value='';
  if(file.name.endsWith('.csv')) importCSV(file);
  else if(file.name.endsWith('.xlsx')) importExcel(file);
  else errorBox.textContent='âŒ ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹';
}

/* ===== CSV å¼ºå®¹é”™è§£æ ===== */
function importCSV(file){
  const r=new FileReader();
  r.onload=()=>{
    const rows=parseCSV(r.result);
    convertRows(rows);
  };
  r.readAsText(file,'utf-8');
}

/* ===== Excel æŒ‰è¡¨å¤´è§£æ ===== */
function importExcel(file){
  const r=new FileReader();
  r.onload=e=>{
    const wb=XLSX.read(new Uint8Array(e.target.result),{type:'array'});
    const ws=wb.Sheets[wb.SheetNames[0]];
    const json=XLSX.utils.sheet_to_json(ws,{defval:''});
    const rows=json.map(o=>[
      o.line,o.stations,o.company,o.price,
      o.area,o.type,o.start_time,o.end_time,o.color
    ]);
    convertRows(rows);
  };
  r.readAsArrayBuffer(file);
}

/* ===== è½¬æ¢ + æŠ¥é”™ ===== */
function convertRows(rows){
  let out='',errors=[];
  rows.forEach((c,i)=>{
    if(!c||!c[0]) return;
    if(!c[4]) errors.push(`ç¬¬ ${i+2} è¡Œç¼ºå°‘ area`);
    let txt=`ã€${c[0]}ã€‘${c[1]||''}-{${c[2]||''}}ã€Š${c[3]||''}ã€‹ã€${c[4]||''}ã€`;
    if(c[5]&&c[5]!=='å…¬äº¤') txt+=`Î¸${c[5]}Î¸`;
    txt+=`Â§${c[6]||''}Â§@${c[7]||''}@`;
    if(c[8]) txt+=`âˆ®${c[8]}âˆ®`;
    out+=txt+'\n';
  });
  output.value=out;
  if(errors.length) errorBox.textContent='âš  å¯¼å…¥è­¦å‘Šï¼š\n'+errors.join('\n');
}

/* ===== CSV è§£æå™¨ ===== */
function parseCSV(text){
  const lines=text.replace(/\r/g,'').split('\n');
  const res=[];
  for(let i=1;i<lines.length;i++){
    let row=[],cur='',q=false;
    for(let c of lines[i]){
      if(c==='"') q=!q;
      else if(c===','&&!q){row.push(cur);cur='';}
      else cur+=c;
    }
    row.push(cur);
    res.push(row.map(s=>s.replace(/^"|"$/g,'')));
  }
  return res;
}

function safe(v){
  v=v??'';
  return `"${String(v).replace(/"/g,'""')}"`;
}
function download(data,name,type){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([data],{type}));
  a.download=name;a.click();
}
</script>
</body>
</html>
